// QE IP Example
// QE Driver (qe_driver.c)
// Jason Losh

//-----------------------------------------------------------------------------
// Hardware Target
//-----------------------------------------------------------------------------

// Target Platform: Xilinx XUP Blackboard

// Hardware configuration:
// 
// AXI4-Lite interface
//   Mapped to offset of 0x10000
// 
// QE 0 and 1 interface:
//   GPIO[11-10] are used for QE 0 inputs
//   GPIO[9-8] are used for QE 1 inputs

// Load kernel module with insmod qe_driver.ko [param=___]

//-----------------------------------------------------------------------------

#include <linux/kernel.h>     // kstrtouint
#include <linux/module.h>     // MODULE_ macros
#include <linux/init.h>       // __init
#include <linux/kobject.h>    // kobject, kobject_atribute,
                              // kobject_create_and_add, kobject_put
#include <asm/io.h>           // iowrite, ioread, ioremap_nocache (platform specific)
#include "../address_map.h"   // overall memory map
#include "qe_regs.h"          // register offsets in QE IP

//-----------------------------------------------------------------------------
// Kernel module information
//-----------------------------------------------------------------------------

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Jason Losh");
MODULE_DESCRIPTION("QE IP Driver");

//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------

static unsigned int *base = NULL;

//-----------------------------------------------------------------------------
// Subroutines
//-----------------------------------------------------------------------------

// Mode
void setMode(uint8_t mode)
{
    iowrite32(mode, base + OFS_MODE);
}

int32_t getMode()
{
    return ioread32(base + OFS_MODE);
}

// Run

// Freq A
void setfreqA(unsigned int freqA)
{
    iowrite32(freqA, base + OFS_FREQ_A);
}

int32_t getfreqA(uint8_t freqA)
{
    return ioread32(base + (OFS_FREQ_A + (freqA * 2)));
}

// Freq B
void setfreqB(unsigned int freqB)
{
    iowrite32(freqB, base + OFS_FREQ_B);
}

int32_t getfreqB(uint8_t freqB)
{
    return ioread32(base + (OFS_FREQ_B + (freqB * 2)));
}

// Offset
void setOffset(unsigned int offset)
{
    iowrite32(offset, base + OFS_PERIOD);
}

int32_t getOffset(uint8_t offset)
{
    return ioread32(base + (OFS_OFFSET + (offset * 2)));
}

// Amplitude
void setAmplitude(uint32_t amplitude)
{
    iowrite32(amplitude, base + OFS_AMPLITUDE);
}

uint32_t getAmplitude()
{
    return ioread32(base + OFS_AMPLITUDE);
}

// Duty Cycle
void setDutyCycle(uint32_t dutyCycle)
{
    iowrite32(dutyCycle, base + OFS_DTYCYC);
}

uint32_t getDutyCycle()
{
    return ioread32(base + OFS_DTYCYC);
}

// Cycles
void setCycle(uint32_t cycle)
{
    iowrite32(cycle, base + OFS_CYCLES);
}

uint32_t getCycle()
{
    return ioread32(base + OFS_CYCLES);
}

// PHASE OFFS
void setPhaseOffset(uint32_t phaseOffset)
{
    iowrite32(phaseOffset, base + OFS_PHASE_OFFS);
}

uint32_t getPhaseOffset()
{
    return ioread32(base + OFS_PHASE_OFFS);
}

//-----------------------------------------------------------------------------
// Need to fix this - 
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Kernel Objects
//-----------------------------------------------------------------------------

static struct kobj_attribute swap0Attr = __ATTR(swap0, 0664, swap0Show, swap0Store);

// Position 0
static int position0 = 0;
module_param(position0, int, S_IRUGO);
MODULE_PARM_DESC(position0, " Position of encoder 0");

static ssize_t position0Store(struct kobject *kobj, struct kobj_attribute *attr, const char *buffer, size_t count)
{
    int result = kstrtouint(buffer, 0, &position0);
    if (result == 0)
        setPosition(0, position0);
    return count;
}

static ssize_t position0Show(struct kobject *kobj, struct kobj_attribute *attr, char *buffer)
{
    position0 = getPosition(0);
    return sprintf(buffer, "%d\n", position0);
}

static struct kobj_attribute position0Attr = __ATTR(position0, 0664, position0Show, position0Store);

// Velocity 0
static int velocity0 = 0;
module_param(velocity0, int, S_IRUGO);
MODULE_PARM_DESC(velocity0, " Velocity of encoder 0");

static ssize_t velocity0Show(struct kobject *kobj, struct kobj_attribute *attr, char *buffer)
{
    velocity0 = getVelocity(0);
    return sprintf(buffer, "%d\n", velocity0);
}

static struct kobj_attribute velocity0Attr = __ATTR(velocity0, 0444, velocity0Show, NULL);

// Enable 1
static int enable1 = 0;
module_param(enable1, int, S_IRUGO);
MODULE_PARM_DESC(enable1, " Enable encoder 1");

static ssize_t enable1Store(struct kobject *kobj, struct kobj_attribute *attr, const char *buffer, size_t count)
{
    if (strncmp(buffer, "true", count-1) == 0)
    {
        enableChannel(1);
        enable1 = true;
    }
    else
        if (strncmp(buffer, "false", count-1) == 0)
        {
            disableChannel(1);
            enable1 = false;
        }
    return count;
}

static ssize_t enable1Show(struct kobject *kobj, struct kobj_attribute *attr, char *buffer)
{
    enable1 = isChannelEnabled(1);
    if (enable1)
        strcpy(buffer, "true\n");
    else
        strcpy(buffer, "false\n");
    return strlen(buffer);
}

static struct kobj_attribute enable1Attr = __ATTR(enable1, 0664, enable1Show, enable1Store);

// Position 1
static int position1 = 0;
module_param(position1, int, S_IRUGO);
MODULE_PARM_DESC(position1, " Position of encoder 1");

static ssize_t position1Store(struct kobject *kobj, struct kobj_attribute *attr, const char *buffer, size_t count)
{
    int result = kstrtouint(buffer, 0, &position1);
    if (result == 0)
        setPosition(1, position1);
    return count;
}

static ssize_t position1Show(struct kobject *kobj, struct kobj_attribute *attr, char *buffer)
{
    position1 = getPosition(1);
    return sprintf(buffer, "%d\n", position1);
}

static struct kobj_attribute position1Attr = __ATTR(position1, 0664, position1Show, position1Store);

// Velocity 1
static int velocity1 = 0;
module_param(velocity1, int, S_IRUGO);
MODULE_PARM_DESC(velocity1, " Velocity of encoder 1");

static ssize_t velocity1Show(struct kobject *kobj, struct kobj_attribute *attr, char *buffer)
{
    velocity1 = getVelocity(1);
    return sprintf(buffer, "%d\n", velocity1);
}

static struct kobj_attribute velocity1Attr = __ATTR(velocity1, 0444, velocity1Show, NULL);

// Timebase of velocity measurement
static unsigned int period = 5000000;
module_param(period, uint, S_IRUGO);
MODULE_PARM_DESC(period, " Timebase of velocity measurement (in system clocks)");

static ssize_t periodStore(struct kobject *kobj, struct kobj_attribute *attr, const char *buffer, size_t count)
{
    int result = kstrtouint(buffer, 0, &period);
    if (result == 0)
        setVelocityTimebase(period);
    return count;
}

static ssize_t periodShow(struct kobject *kobj, struct kobj_attribute *attr, char *buffer)
{
    return sprintf(buffer, "%u\n", period);
}

static struct kobj_attribute periodAttr = __ATTR(period, 0664, periodShow, periodStore);

// Attributes

static struct attribute *attrs0[] = {&enable0Attr.attr, &swap0Attr.attr, &position0Attr.attr, &velocity0Attr.attr, &periodAttr.attr, NULL};
static struct attribute *attrs1[] = {&enable1Attr.attr, &swap1Attr.attr, &position1Attr.attr, &velocity1Attr.attr, &periodAttr.attr, NULL};

static struct attribute_group group0 =
{
    .name = "qe0",
    .attrs = attrs0
};

static struct attribute_group group1 =
{
    .name = "qe1",
    .attrs = attrs1
};

static struct kobject *kobj;

//-----------------------------------------------------------------------------
// Initialization and Exit
//-----------------------------------------------------------------------------

static int __init initialize_module(void)
{
    int result;

    printk(KERN_INFO "QE driver: starting\n");

    // Create qe directory under /sys/kernel
    kobj = kobject_create_and_add("qe", NULL); //kernel_kobj);
    if (!kobj)
    {
        printk(KERN_ALERT "QE driver: failed to create and add kobj\n");
        return -ENOENT;
    }

    // Create qe0 and qe1 groups
    result = sysfs_create_group(kobj, &group0);
    if (result !=0)
        return result;
    result = sysfs_create_group(kobj, &group1);
    if (result !=0)
        return result;

    // Physical to virtual memory map to access gpio registers
    base = (unsigned int*)ioremap(AXI4_LITE_BASE + QE_BASE_OFFSET,
                                          QE_SPAN_IN_BYTES);
    if (base == NULL)
        return -ENODEV;

    printk(KERN_INFO "QE driver: initialized\n");

    return 0;
}

static void __exit exit_module(void)
{
    kobject_put(kobj);
    printk(KERN_INFO "QE driver: exit\n");
}

module_init(initialize_module);
module_exit(exit_module);

